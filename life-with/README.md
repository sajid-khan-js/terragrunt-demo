# Life with terragrunt

> Although there is an initial learning curve and setup with terragrunt, the
> payoff is exponential. Better yet, it's super flexible, so once you're
> comfortable with it, you can create structures that fit your architecture and
> workflow

:memo: To keep things simple, this example terragrunt structure was setup for a
single AWS region, and does not explicitly declare multiple AWS accounts
(although in theory you could just flip your AWS credentials whilst in the prd
or dev directory). The "standard" structure found
[here](https://github.com/gruntwork-io/terragrunt-infrastructure-live-example)
demonstrates how use terragrunt in a multi-region, multi-account setup.

## Guide: "It just works"

```sh
# cd into dev or prd 
terragrunt run-all plan
```

## Comparison

Err this is about the same amount of code as the vanilla terraform setup and
seems a bit more complicated? You are right on both counts, but as you add more
environments and more deployments the amount of config required to scale the
terragrunt setup is considerably less when compared to a vanilla terraform
setup. Also, that complexity is defined as declarative code, not a process you
need to remember or a hacky imperative Bash script that would struggle with all
the complexity.

Furthermore, the vanilla terraform setup is quite advanced, I would not expect
someone fairly new to terraform to cook that up, so right now it's vanilla
terraform's best shot vs terragrunt's MVP (minimum viable product), and in my
opinion, terragrunt still wins.

### Features

:memo: There is additional commentary in some of the terragrunt config files,
[here](./terragrunt.hcl) and [here](./dev/eks/terragrunt.hcl)

- Single source of truth for everything:
  - Global variables e.g. region. See if you can find more than once instance of
    `eu-west-1`, now try searching the `life-without` folder
  - Environment level variables e.g. env name
- Backend config is done automatically i.e. it auto generates a backend.tf file
  with the relevant bucket, region, key
  - The state sorts itself out, the "key" i.e. state path is auto generated by
    the actual path in your terragrunt setup. This means your state bucket and
    code repo are mirrored, makes life much easier when debugging terraform
    state files.
- Provider config is done automatically i.e. it auto generates a provider.tf
  file, this is super useful if you rely on role assumption
- There's no need to define variables or outputs again from the module we are
  calling i.e. no variables.tf or outputs.tf
- Adding a env is super easy; copy an existing env folder, make any required
  changes in `env.hcl`, and you're done.
- Meta terraform: You can use familiar terraform functions in terragrunt config
  files e.g. locals, merge, split etc.
- Orchestrate complete environments with one command (e.g. `terragrunt run-all
  plan`). This is because terragrunt allows you to define dependencies, so it
  knows you need your VPC up and running first before attempting to spin up your
  EKS cluster. Even better, it will grab the outputs from the VPC module (e.g.
  VPC ID) for you when it's time to spin up the EKS module.
